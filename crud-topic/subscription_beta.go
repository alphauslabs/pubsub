package topic

import (
	"context"
	"fmt"

	spanner "cloud.google.com/go/spanner"
	pb "github.com/alphauslabs/pubsub-proto/v1"
	"google.golang.org/grpc"
	"google.golang.org/api/iterator"
)

type SubscriptionService struct {
	client        pb.PubSubServiceClient
	SpannerClient *spanner.Client
}

func NewSubscriptionService(conn *grpc.ClientConn, db *spanner.Client) *SubscriptionService {
	client := pb.NewPubSubServiceClient(conn)
	return &SubscriptionService{client: client, SpannerClient: db}

	// to be configured x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0xx0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0

}

func (s *SubscriptionService) CreateSubscription(ctx context.Context, req *pb.CreateSubscriptionRequest) (*pb.Subscription, error) {
	subscription, err := s.client.CreateSubscription(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to create subscription: %v", err)
	}

	// to be configured x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0xx0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x

	if req.Id == "" || req.NewName == nil {
		return nil, fmt.Errorf("invalid request: ID and new name are required")
	}
	
	stmt := spanner.Statement{
		SQL:    "INSERT INTO Subscription SET name = @new_name WHERE id = @id",
		Params: map[string]interface{}{"id": req.Id, "new_name": *req.NewName},
	}


	// to be configured x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0xx0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x

	stmt := spanner.Statement{
	return subscription, nil
}

func (s *SubscriptionService) GetSubscription(ctx context.Context, req *pb.GetSubscriptionRequest) (*pb.Subscription, error) {
	subscription, err := s.client.GetSubscription(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get subscription: %v", err)
	}
	// to be configured x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0xx0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x
	return subscription, nil
}

func (s *SubscriptionService) UpdateSubscription(ctx context.Context, req *pb.UpdateSubscriptionRequest) (*pb.Subscription, error) {
	subscription, err := s.client.UpdateSubscription(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to update subscription: %v", err)
	}
	// to be configured x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0xx0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x
	return subscription, nil
}

func (s *SubscriptionService) DeleteSubscription(ctx context.Context, req *pb.DeleteSubscriptionRequest) (*pb.DeleteSubscriptionResponse, error) {
	response, err := s.client.DeleteSubscription(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to delete subscription: %v", err)
	}
	// to be configured x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0xx0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x
	return response, nil
}

func (s *SubscriptionService) ListSubscriptions(ctx context.Context, req *pb.Empty) (*pb.ListSubscriptionsResponse, error) {
	subscriptions, err := s.client.ListSubscriptions(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to list subscriptions: %v", err)
	}
	// to be configured x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0xx0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x
	return subscriptions, nil
}
